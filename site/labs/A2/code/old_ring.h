#ifndef RING_H
#define RING_H

template <typename T>
class Ring {
public:
  Ring(unsigned capacity=8);
  Ring(const Ring<T>&);
  ~Ring();
  void add(const T&);
  T operator[](unsigned);
  unsigned size() const;
  unsigned capacity() const;

  class iterator {
  public:
    iterator(unsigned);
    T operator*() const;
    iterator operator++();
    bool operator!=(const iterator& other);
  private:
    unsigned current;
  };

  iterator begin() const;
  iterator end() const;

private:
  T* items;
  unsigned position;
  unsigned num_items;
  unsigned capacity_size;
};

/* Constructor; should create an empty ring of size capacity which defaults to 8 if not given. */

template <typename T>
Ring<T>::Ring(unsigned capacity) {}

/* Copy Constructor: note that this is generated by default, but the default copy constructor does the wrong thing */

template <typename T>
Ring<T>::Ring(const Ring<T>& rhs) {}

/* Destructor needs to free up memory */

template <typename T>
Ring<T>::~Ring() {}

/* add: add item to the ring.  This may need to resize the list (if you want you can create another function resize in the head file Ring.h). In the standard library this would be called push. */

template <typename T>
void Ring<T>::add(const T& item) {}

/* operator[]: This should return the i^th element counting backwards.  If it is called with an index greater than the number of items in the ring then it should throw an exception "this item is not stored" */

template <typename T>
T Ring<T>::operator[](unsigned index) {return T(-1);}

/* size: returns the number of items in the ring.  As this can't be negative we make this an unsigned integer.  The const in the definition tells us that this command does not change the Ring data structure */

template <typename T>
unsigned Ring<T>::size() const {return 999;}

/* capacity: tells up how much memory we have reserved */

template <typename T>
unsigned Ring<T>::capacity() const {return 0;}


/* constructure for the nested class iterator: note that this has access to the data held in ring */

template <typename T>
Ring<T>::iterator::iterator(unsigned i) {}

/* dereferencing operator should return whatever the iterator "points to" */

template <typename T>
T Ring<T>::iterator::operator*() const {return T(0);}

/* need a way to check that the iterator is not the end iterator */

template <typename T>
bool Ring<T>::iterator::operator!=(const iterator& other) {return false;}
/* need a way to check that the iterator is not the end iterator */

template <typename T>
typename Ring<T>::iterator Ring<T>::iterator::operator++() {return iterator(0);}

/* code to return a new iterator: you are free to define this however you want to */

template <typename T>
typename Ring<T>::iterator Ring<T>::begin() const {return iterator(0);}

/* code to return a "point" past the last iterator: you are free to choose this however you like. */

template <typename T>
typename Ring<T>::iterator Ring<T>::end() const {return iterator(0);}


#endif
