#ifndef QUEUE_H
#define QUEUE_H

#include <iostream>
using namespace std;

template <typename T>
class Queue {
public:
  Queue();
  Queue(const Queue<T>&);
  ~Queue();
  void enqueue(const T&);
  T dequeue();
  unsigned size() const;
  unsigned capacity() const;
  bool is_empty() const;
  bool resize_capacity(unsigned);
private:
  T* items;
  unsigned front;
  unsigned num_items;
  unsigned capacity_size;
};

/* Constructor; should create an empty queue with capacity 8 */

template <typename T>
Queue<T>::Queue(): front(0), num_items(0), capacity_size(8) {
  items = new T[capacity_size];
}

/* Copy Constructor: note that this is generated by default, but the default copy constructor does the wrong thing */

template <typename T>
Queue<T>::Queue(const Queue<T>& rhs) {
  items = new T[rhs.capacity()];
  capacity_size = rhs.capacity();
  front = 0;
  num_items = rhs.size();
  for(unsigned i=0; i<num_items; ++i) {
    items[i] = rhs.items[front+i%capacity_size];
  }
}

/* Destructor needs to free up memory */

template <typename T>
Queue<T>::~Queue() {
  delete[] items;
}

/* enqueue: add item to the list.  This may need to resize the list (if you want you can create another function resize in the head file Queue.h). In the standard library this would be called push. */

template <typename T>
void Queue<T>::enqueue(const T& item) {
  if (num_items == capacity_size) {
    resize_capacity(2*capacity_size);
  }
  items[(front+num_items)%capacity_size] = item;
  ++num_items;
}

/* dequeue: remove the first element in the queue and returns it (in the standard library top() would return the first element in the queuue but not remove it.  pop() would remove the first element in the queue, but not return anything).  This should throw std::out_of_range when the queue is empty */

template <typename T>
T Queue<T>::dequeue() {
  if (num_items==0) {
    throw "can't dequeue queue is empty";
  }
  T item = items[front];
  front = (front==capacity_size-1)? 0: front + 1;
  --num_items;
  return item;
}

/* size: returns the number of elements in the queue.  As this can't be negative we make this an unsigned integer.  The const in the definition tells us that this command does not change the Queue data structure */

template <typename T>
unsigned Queue<T>::size() const {
  return num_items;
}

/* is_empty: returns true if queue is empty */

template <typename T>
bool Queue<T>::is_empty() const {
  return num_items == 0;
}

/* capacity: tells up how much memory we have reserved */

template <typename T>
unsigned Queue<T>::capacity() const {
  return capacity_size;
}

/* resize_capacity: if the capacity request is at least as large as the number of elements the capacity should be modified and return true other leave the capacity unchanged and return false */

template <typename T>
bool Queue<T>::resize_capacity(unsigned capacity_request) {
  if (capacity_request<num_items)
    return false;

  T* new_items = new T[capacity_request];
  for(unsigned i=0; i<num_items; ++i) {
    new_items[i] = items[(front + i)%capacity_size];
  }
  delete[] items;
  items = new_items;
  capacity_size = capacity_request;
  front = 0;
  return true;
}


#endif
