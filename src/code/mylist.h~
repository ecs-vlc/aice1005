#ifndef MYLIST_H
#define MYLIST_H

template <typename T>
class MyList {
private:
  template <typename U>
  struct Node{
    Node(U value, Node<U> *node): value(value), next(node) {}
    U value;
    Node<U> *next;
  };

  template <typename U>
  struct list_iterator {
    list_iterator(Node<U> *pt): entry(pt) {}
    U& operator*() {return entry->value;}
    const U& operator*() const {return entry->value;}
    list_iterator<U> operator++() {
      entry = entry->next;
      return entry;
    }
    bool operator!=(const list_iterator<U>& other) const {
      return entry != other.entry;
    }

    Node<U> *entry;
  };
  
  Node<T> *head;
  unsigned n;
public:
  
  MyList(): n(0), head(0) {}
  
  unsigned size() const {return n;}
  
  void push(T value) {
    Node<T> *start = new Node<T>(value, head);
    head = start;
    ++n;
  }

  T top() const {return head->value;}
  
  void pop() {
    Node<T> *dead = head;
    head = dead->next;
    delete dead;
    --n;
  }
  
  bool empty() const {
    return head == 0;
  }

  ~MyList() {
    while (!empty()) {
      pop();
    }
  }

  list_iterator<T> begin() {return list_iterator<T>(head);}
  list_iterator<T> end() {return list_iterator<T>(0);}
  
};

#endif
